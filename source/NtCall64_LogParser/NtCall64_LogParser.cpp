/*******************************************************************************
*
*  NTCALL64 Log File Parser
*
*  Parses log files generated by NTCALL64 -log switch (binary format).
*
*******************************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define NC64_LOG_MAX_ARGS 16

#pragma pack(push, 1)
typedef struct _NC64_SYSCALL_LOG_ENTRY {
    ULONG SyscallNumber;
    ULONG ArgCount;
    ULONG_PTR Arguments[NC64_LOG_MAX_ARGS];
} NC64_SYSCALL_LOG_ENTRY, * PNC64_SYSCALL_LOG_ENTRY;
#pragma pack(pop)

void print_entry(const NC64_SYSCALL_LOG_ENTRY* entry, size_t index) {
    printf("Entry %zu:\n", index);
    printf("  SyscallNumber: %lu (0x%lX)\n", entry->SyscallNumber, entry->SyscallNumber);
    printf("  Argument Count: %lu\n", entry->ArgCount);
    for (ULONG i = 0; i < entry->ArgCount && i < NC64_LOG_MAX_ARGS; ++i) {
#ifdef _WIN64
        printf("    Arg[%02lu]: 0x%016llX\n", i, (unsigned long long)entry->Arguments[i]);
#else
        printf("    Arg[%02lu]: 0x%08lX\n", i, (unsigned long)entry->Arguments[i]);
#endif
    }
    printf("\n");
}

int main(int argc, char* argv[])
{
    if (argc != 2) {
        printf("Usage: %s <ntcall64_log_file>\n", argv[0]);
        return 1;
    }

    const char* filename = argv[1];
    FILE* f = NULL;
    errno_t err = fopen_s(&f, filename, "rb");
    if (err != 0 || f == NULL) {
        fprintf(stderr, "Error opening log file: %s\n", filename);
        return 1;
    }

    NC64_SYSCALL_LOG_ENTRY entry;
    size_t entry_size = sizeof(NC64_SYSCALL_LOG_ENTRY);
    size_t index = 0;

    while (fread(&entry, 1, entry_size, f) == entry_size) {
        print_entry(&entry, index);
        ++index;
    }

    if (!feof(f)) {
        fprintf(stderr, "Warning: incomplete or corrupt log file detected at entry %zu.\n", index);
    }

    fclose(f);
    printf("Done. %zu entries read.\n", index);
    return 0;
}